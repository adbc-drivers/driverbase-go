// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Vendored from upstream go/adbc/driver/internal

package driverbase

import (
	"regexp"
	"strings"

	"github.com/apache/arrow-adbc/go/adbc"
	"github.com/apache/arrow-go/v18/arrow"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

const (
	Unique     = "UNIQUE"
	PrimaryKey = "PRIMARY KEY"
	ForeignKey = "FOREIGN KEY"
)

var (
	AcceptAll = regexp.MustCompile(".*")
)

// Helper function that compiles a SQL-style pattern (%, _) to a regex
func PatternToRegexp(pattern *string) (*regexp.Regexp, error) {
	if pattern == nil {
		return nil, nil
	}

	var builder strings.Builder
	if _, err := builder.WriteString("(?i)^"); err != nil {
		return nil, err
	}
	for _, c := range *pattern {
		switch {
		case c == rune('_'):
			if _, err := builder.WriteString("."); err != nil {
				return nil, err
			}
		case c == rune('%'):
			if _, err := builder.WriteString(".*"); err != nil {
				return nil, err
			}
		default:
			if _, err := builder.WriteString(regexp.QuoteMeta(string([]rune{c}))); err != nil {
				return nil, err
			}
		}
	}
	if _, err := builder.WriteString("$"); err != nil {
		return nil, err
	}
	return regexp.Compile(builder.String())
}

const (
	COLUMN_NAME                 = "COLUMN_NAME"
	ORDINAL_POSITION            = "ORDINAL_POSITION"
	REMARKS                     = "REMARKS"
	XDBC_DATA_TYPE              = "XDBC_DATA_TYPE"
	XDBC_TYPE_NAME              = "XDBC_TYPE_NAME"
	XDBC_COLUMN_SIZE            = "XDBC_COLUMN_SIZE"
	XDBC_DECIMAL_DIGITS         = "XDBC_DECIMAL_DIGITS"
	XDBC_NUM_PREC_RADIX         = "XDBC_NUM_PREC_RADIX"
	XDBC_NULLABLE               = "XDBC_NULLABLE"
	XDBC_COLUMN_DEF             = "XDBC_COLUMN_DEF"
	XDBC_SQL_DATA_TYPE          = "XDBC_SQL_DATA_TYPE"
	XDBC_DATETIME_SUB           = "XDBC_DATETIME_SUB"
	XDBC_CHAR_OCTET_LENGTH      = "XDBC_CHAR_OCTET_LENGTH"
	XDBC_IS_NULLABLE            = "XDBC_IS_NULLABLE"
	XDBC_SCOPE_CATALOG          = "XDBC_SCOPE_CATALOG"
	XDBC_SCOPE_SCHEMA           = "XDBC_SCOPE_SCHEMA"
	XDBC_SCOPE_TABLE            = "XDBC_SCOPE_TABLE"
	XDBC_IS_AUTOINCREMENT       = "XDBC_IS_AUTOINCREMENT"
	XDBC_IS_AUTOGENERATEDCOLUMN = "XDBC_IS_AUTOGENERATEDCOLUMN"
)

// The JDBC/ODBC-defined type of any object.
// All the values here are the sames as in the JDBC and ODBC specs.
type XdbcDataType int32

const (
	XdbcDataType_XDBC_UNKNOWN_TYPE  XdbcDataType = 0
	XdbcDataType_XDBC_CHAR          XdbcDataType = 1
	XdbcDataType_XDBC_NUMERIC       XdbcDataType = 2
	XdbcDataType_XDBC_DECIMAL       XdbcDataType = 3
	XdbcDataType_XDBC_INTEGER       XdbcDataType = 4
	XdbcDataType_XDBC_SMALLINT      XdbcDataType = 5
	XdbcDataType_XDBC_FLOAT         XdbcDataType = 6
	XdbcDataType_XDBC_REAL          XdbcDataType = 7
	XdbcDataType_XDBC_DOUBLE        XdbcDataType = 8
	XdbcDataType_XDBC_DATETIME      XdbcDataType = 9
	XdbcDataType_XDBC_INTERVAL      XdbcDataType = 10
	XdbcDataType_XDBC_VARCHAR       XdbcDataType = 12
	XdbcDataType_XDBC_DATE          XdbcDataType = 91
	XdbcDataType_XDBC_TIME          XdbcDataType = 92
	XdbcDataType_XDBC_TIMESTAMP     XdbcDataType = 93
	XdbcDataType_XDBC_LONGVARCHAR   XdbcDataType = -1
	XdbcDataType_XDBC_BINARY        XdbcDataType = -2
	XdbcDataType_XDBC_VARBINARY     XdbcDataType = -3
	XdbcDataType_XDBC_LONGVARBINARY XdbcDataType = -4
	XdbcDataType_XDBC_BIGINT        XdbcDataType = -5
	XdbcDataType_XDBC_TINYINT       XdbcDataType = -6
	XdbcDataType_XDBC_BIT           XdbcDataType = -7
	XdbcDataType_XDBC_WCHAR         XdbcDataType = -8
	XdbcDataType_XDBC_WVARCHAR      XdbcDataType = -9
)

func ToXdbcDataType(dt arrow.DataType) (xdbcType XdbcDataType) {
	if dt == nil {
		return XdbcDataType_XDBC_UNKNOWN_TYPE
	}

	switch dt.ID() {
	case arrow.EXTENSION:
		return ToXdbcDataType(dt.(arrow.ExtensionType).StorageType())
	case arrow.DICTIONARY:
		return ToXdbcDataType(dt.(*arrow.DictionaryType).ValueType)
	case arrow.RUN_END_ENCODED:
		return ToXdbcDataType(dt.(*arrow.RunEndEncodedType).Encoded())
	case arrow.INT8, arrow.UINT8:
		return XdbcDataType_XDBC_TINYINT
	case arrow.INT16, arrow.UINT16:
		return XdbcDataType_XDBC_SMALLINT
	case arrow.INT32, arrow.UINT32:
		return XdbcDataType_XDBC_INTEGER
	case arrow.INT64, arrow.UINT64:
		return XdbcDataType_XDBC_BIGINT
	case arrow.FLOAT32, arrow.FLOAT16, arrow.FLOAT64:
		return XdbcDataType_XDBC_FLOAT
	case arrow.DECIMAL, arrow.DECIMAL256:
		return XdbcDataType_XDBC_DECIMAL
	case arrow.STRING, arrow.LARGE_STRING:
		return XdbcDataType_XDBC_VARCHAR
	case arrow.BINARY, arrow.LARGE_BINARY:
		return XdbcDataType_XDBC_BINARY
	case arrow.FIXED_SIZE_BINARY:
		return XdbcDataType_XDBC_BINARY
	case arrow.BOOL:
		return XdbcDataType_XDBC_BIT
	case arrow.TIME32, arrow.TIME64:
		return XdbcDataType_XDBC_TIME
	case arrow.DATE32, arrow.DATE64:
		return XdbcDataType_XDBC_DATE
	case arrow.TIMESTAMP:
		return XdbcDataType_XDBC_TIMESTAMP
	case arrow.DENSE_UNION, arrow.SPARSE_UNION:
		return XdbcDataType_XDBC_VARBINARY
	case arrow.LIST, arrow.LARGE_LIST, arrow.FIXED_SIZE_LIST:
		return XdbcDataType_XDBC_VARBINARY
	case arrow.STRUCT, arrow.MAP:
		return XdbcDataType_XDBC_VARBINARY
	default:
		return XdbcDataType_XDBC_UNKNOWN_TYPE
	}
}

func SetErrorOnSpan(span trace.Span, err error) bool {
	if err != nil {
		span.RecordError(err)
		if adbcError, ok := err.(adbc.Error); ok {
			span.SetAttributes(attribute.String("error.type", adbcError.Code.String()))
		}
		span.SetStatus(codes.Error, err.Error())
		return true
	}
	return false
}
